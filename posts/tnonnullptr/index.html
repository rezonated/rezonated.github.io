<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width"><link rel=icon type=image/ico href=https://rezonated.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://rezonated.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://rezonated.github.io/favicon-32x32.png><link rel=icon type=image/png sizes=192x192 href=https://rezonated.github.io/android-chrome-192x192.png><link rel=apple-touch-icon sizes=180x180 href=https://rezonated.github.io/apple-touch-icon.png><meta name=description content="This article showcases TNonNullPtr, a lightweight container that provides guardrails for nullptr values"><title>TNonNullPtr: UE's bouncer for null pointers! | V's personal site</title><link rel=canonical href=https://rezonated.github.io/posts/tnonnullptr/><meta property="og:url" content="https://rezonated.github.io/posts/tnonnullptr/"><meta property="og:site_name" content="V's personal site"><meta property="og:title" content="TNonNullPtr: UE's bouncer for null pointers!"><meta property="og:description" content="This article showcases TNonNullPtr, a lightweight container that provides guardrails for nullptr values"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-11-08T00:00:00+00:00"><meta property="article:modified_time" content="2025-11-08T00:00:00+00:00"><meta property="article:tag" content="Ue"><meta property="article:tag" content="C++"><link rel=stylesheet href=/assets/combined.min.44deaa6678e01a128f508829cd0a154395ad2bd3fb767197239c535cd99516a1.css media=all></head><body class=dark><div class=content><header><div class=header></div></header><main class=main><div class=breadcrumbs><a href=/>~</a><span class=breadcrumbs-separator>/</span><a href=/posts/>Posts</a><span class=breadcrumbs-separator>/</span>
<a href=/posts/tnonnullptr/>TNonNullPtr: UE's bouncer for null pointers!</a></div><div><article><header class=single-intro-container><h1 class=single-title>TNonNullPtr: UE's bouncer for null pointers!</h1><div class=single-subsummary><div><p class=single-date><time datetime=2025-11-08T00:00:00+00:00>November 8, 2025</time>
&nbsp; · &nbsp;7 min read</p></div></div></header><div class=single-content><h1 class=heading id=introduction>Introduction
<a class=anchor href=#introduction>#</a></h1><p>If you&rsquo;ve spent any time writing gameplay code in Unreal&rsquo;s C++, you know the routine. The code we all have to write.</p><p>Before you can safely use a pointer, you have to check it. This defensive habit is essential for preventing crashes, but it often leads to code that looks like this:</p><div class=highlight><pre tabindex=0 style=color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#666"> 1</span><span><span style=color:#00cd00>void</span> AMyGameMode<span style=color:#39c>::</span>StartRound(<span style=color:#cdcd00>const</span> AController<span style=color:#39c>*</span> PlayerController)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#666"> 2</span><span>{
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#666"> 3</span><span>	<span style=color:#cdcd00>if</span> (PlayerController)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#666"> 4</span><span>	{
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#666"> 5</span><span>		<span style=color:#cdcd00>if</span> (PlayerController<span style=color:#39c>-&gt;</span>GetPawn<span style=color:#39c>&lt;</span>AMyCharacter<span style=color:#39c>&gt;</span>())
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#666"> 6</span><span>		{
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#666"> 7</span><span>			<span style=color:#cdcd00>if</span> (PlayerController<span style=color:#39c>-&gt;</span>GetPawn<span style=color:#39c>&lt;</span>AMyCharacter<span style=color:#39c>&gt;</span>()<span style=color:#39c>-&gt;</span>GetMyWeaponComponent())
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#666"> 8</span><span>			{
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#666"> 9</span><span>				PlayerController<span style=color:#39c>-&gt;</span>GetPawn<span style=color:#39c>&lt;</span>AMyCharacter<span style=color:#39c>&gt;</span>()<span style=color:#39c>-&gt;</span>GetMyWeaponComponent()<span style=color:#39c>-&gt;</span>EquipWeapon();
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#666">10</span><span>			}
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#666">11</span><span>		}
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#666">12</span><span>	}
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#666">13</span><span>}
</span></span></code></pre></div><p>This code is safe, perfectly fine. But it&rsquo;s not clean. The core intent is buried under layers of validation. What if&mldr; we could flip this pattern on its head?</p><p>Instead of defensively checking for nulls <em>inside</em> our functions, what if we&mldr; could enforce a rule that a pointer is <strong>never</strong> null when it arrives?</p><h1 class=heading id=meet-the-bouncer---tnonnullptr>Meet the bouncer - <code>TNonNullPtr</code>
<a class=anchor href=#meet-the-bouncer---tnonnullptr>#</a></h1><p>Think of <code>TNonNullPtr</code> as a bouncer at a club. Its job is simple, but important. Here&rsquo;s its code of conduct:</p><ol><li>I do not <strong>own</strong> the people in the club. My job is just to check them (Non-owning)</li><li>I check everyone&rsquo;s ID at the door (Non-null guarantee)</li><li>If someone shows up with an invalid ID (<code>nullptr</code>), I don&rsquo;t let them in. I stop them right there, right now (Asserts on creation)</li></ol><p><code>TNonNullPtr</code> essentially is a lightweight wrapper that makes a powerful promise: <strong>this pointer is valid</strong>.</p><h2 class=heading id=two-layers-of-protection-compile-time-and-runtime>Two layers of protection; compile-time and runtime
<a class=anchor href=#two-layers-of-protection-compile-time-and-runtime>#</a></h2><p><code>TNonNullPtr</code> provides two levels of security by cleverly using C++ features. Let&rsquo;s look at the engine code to see how.</p><ol><li>The compile-time guard rail
For blatant mistakes, <code>TNonNullPtr</code> won&rsquo;t even let you compile. In <code>NonNullPointer.h</code>, the constructor and assignment operator for <code>nullptr</code> are explicitly forbidden using a <code>static_assert</code> trick.</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span>	<span style=color:#6272a4>/**
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span><span style=color:#6272a4>	 * nullptr constructor - not allowed.
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span><span><span style=color:#6272a4>	 */</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span>	UE_FORCEINLINE_HINT <span style=color:#50fa7b>TNonNullPtr</span>(TYPE_OF_NULLPTR)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span><span>	{
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span><span>		<span style=color:#6272a4>// Essentially static_assert(false), but this way prevents GCC/Clang from crying wolf by merely inspecting the function body
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span><span><span style=color:#6272a4></span>		<span style=color:#ff79c6>static_assert</span>(<span style=color:#ff79c6>sizeof</span>(ObjectType) <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>0</span>, <span style=color:#f1fa8c>&#34;Tried to initialize TNonNullPtr with a null pointer!&#34;</span>);
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span><span>	}
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span><span>    <span style=color:#6272a4>/**
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span><span><span style=color:#6272a4>	 * Assignment operator taking a nullptr - not allowed.
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12</span><span><span style=color:#6272a4>	 */</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13</span><span>	<span style=color:#ff79c6>inline</span> TNonNullPtr<span style=color:#ff79c6>&amp;</span> <span style=color:#ff79c6>operator</span><span style=color:#ff79c6>=</span>(TYPE_OF_NULLPTR)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14</span><span>	{
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15</span><span>		<span style=color:#6272a4>// Essentially static_assert(false), but this way prevents GCC/Clang from crying wolf by merely inspecting the function body
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16</span><span><span style=color:#6272a4></span>		<span style=color:#ff79c6>static_assert</span>(<span style=color:#ff79c6>sizeof</span>(ObjectType) <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>0</span>, <span style=color:#f1fa8c>&#34;Tried to assign a null pointer to a TNonNullPtr!&#34;</span>);
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17</span><span>		<span style=color:#ff79c6>return</span> <span style=color:#ff79c6>*</span><span style=color:#ff79c6>this</span>;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18</span><span>	}
</span></span></code></pre></div><p>The <code>static_assert(sizeof(ObjectType) == 0, ...)</code> is a common technique.</p><p>Since no complete type can have a size of zero, this assertion is guaranteed to fail if the compiler ever tries to generate code for these functions. It only tries to do that when it sees you directly using nullptr.</p><p>This is why this code fails to compile:</p><div class=highlight><pre tabindex=0 style=color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#666">1</span><span><span style=color:#00cd00>void</span> AMyCharacter<span style=color:#39c>::</span>BeginPlay()
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#666">2</span><span>{
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#666">3</span><span>	Super<span style=color:#39c>::</span>BeginPlay();
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#666">4</span><span>	
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#666">5</span><span>	TNonNullPtr<span style=color:#39c>&lt;</span>AActor<span style=color:#39c>&gt;</span> SomeActor <span style=color:#39c>=</span> <span style=color:#cdcd00>nullptr</span>;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#666">6</span><span>}
</span></span></code></pre></div><pre tabindex=0><code>0&gt;[1/6] Compile [x64] MyCharacter.cpp
0&gt;NonNullPointer.h(40,36): Error C2338 : static_assert failed: &#39;Tried to initialize TNonNullPtr with a null pointer!&#39;
0&gt;		static_assert(sizeof(ObjectType) == 0, &#34;Tried to initialize TNonNullPtr with a null pointer!&#34;);
0&gt;		                                 ^
0&gt;NonNullPointer.h(40,36): Reference  : the template instantiation context (the oldest one first) is
0&gt;MyCharacter.cpp(23,22): Reference  : see reference to class template instantiation &#39;TNonNullPtr&lt;AActor&gt;&#39; being compiled
0&gt;	TNonNullPtr&lt;AActor&gt; SomeActor = nullptr;
0&gt;	                    ^
0&gt;NonNullPointer.h(37,2): Reference  : while compiling class template member function &#39;TNonNullPtr&lt;AActor&gt;::TNonNullPtr(TYPE_OF_NULLPTR)&#39;
0&gt;	UE_FORCEINLINE_HINT TNonNullPtr(TYPE_OF_NULLPTR)
0&gt;	^
0&gt;MyCharacter.cpp(23,32): Reference  : see the first reference to &#39;TNonNullPtr&lt;AActor&gt;::TNonNullPtr&#39; in &#39;AMyCharacter::BeginPlay&#39;
0&gt;	TNonNullPtr&lt;AActor&gt; SomeActor = nullptr;
</code></pre><p>The compiler sees the <code>nullptr</code> and gives you an error, directly telling where the mistake is, acting as a guard rail before your code even run.</p><ol start=2><li>The runtime bouncer
But what about cases the compiler can&rsquo;t predict? Perhaps a <code>nullptr</code> Player State? A <code>nullptr</code> due to other function call failing to return a valid pointer?</li></ol><p>The constructor that takes a regular pointer uses <code>ensureMsgf</code> to validate it.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span>    <span style=color:#6272a4>/**
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span><span style=color:#6272a4>	 * Constructs a non-null pointer from the provided pointer. Must not be nullptr.
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span><span style=color:#6272a4>	 */</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span><span>	<span style=color:#ff79c6>inline</span> <span style=color:#50fa7b>TNonNullPtr</span>(ObjectType<span style=color:#ff79c6>*</span> InObject)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5</span><span>		<span style=color:#ff79c6>:</span> Object(InObject)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6</span><span>	{
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7</span><span>		ensureMsgf(InObject, TEXT(<span style=color:#f1fa8c>&#34;Tried to initialize TNonNullPtr with a null pointer!&#34;</span>));
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8</span><span>	}
</span></span></code></pre></div><p>This is the bouncer. When your code runs and a variable that happens to be <code>nullptr</code> gets passed in, the <code>ensureMsgf</code> fires.</p><div class=highlight><pre tabindex=0 style=color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#666">1</span><span><span style=color:#00cd00>void</span> AMyCharacter<span style=color:#39c>::</span>BeginPlay()
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#666">2</span><span>{
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#666">3</span><span>	Super<span style=color:#39c>::</span>BeginPlay();
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#666">4</span><span>	
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#666">5</span><span>	AMyGameMode<span style=color:#39c>*</span> MyFoundActor <span style=color:#39c>=</span> Cast<span style=color:#39c>&lt;</span>AMyGameMode<span style=color:#39c>&gt;</span>(UGameplayStatics<span style=color:#39c>::</span>GetActorOfClass(<span style=color:#cdcd00>this</span>, AMyGameMode<span style=color:#39c>::</span>StaticClass()));
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#666">6</span><span>	TNonNullPtr<span style=color:#39c>&lt;</span>AMyGameMode<span style=color:#39c>&gt;</span> MyGameMode <span style=color:#39c>=</span> MyFoundActor;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#666">7</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#666">8</span><span>	MyGameMode<span style=color:#39c>-&gt;</span>StartRound(GetController());
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#666">9</span><span>}
</span></span></code></pre></div><p>This triggers the exception if you&rsquo;re currently running your project with a debugger attached, where you can inspect the stack trace.</p><p><p><img src=/posts/tnonnullptr/runtime_exception.png alt="Runtime exception" title="Whoop, you just got caught!"></p></p><p>And then inside the output log, you&rsquo;ll see the following message</p><pre tabindex=0><code>LogOutputDevice: Warning: Script Stack (0 frames) :
LogOutputDevice: Error: Ensure condition failed: InObject [File:C:\UE_5.7\Engine\Source\Runtime\Core\Public\Templates\NonNullPointer.h] [Line: 49] 
Tried to initialize TNonNullPtr with a null pointer!
LogStats:             FDebug::EnsureFailed -  0.000 s
LogOutputDevice: Warning: Script Stack (0 frames) :
LogOutputDevice: Error: Ensure condition failed: Object [File:C:\UE_5.7\Engine\Source\Runtime\Core\Public\Templates\NonNullPointer.h] [Line: 210] 
Tried to access null pointer!
</code></pre><p>Very handy for catching bugs during development!</p><p>So, you get the best of both worlds; compile-time errors for obvious bugs and runtime checks for the <em>sneaky</em> ones.</p><h1 class=heading id=well-then-why-isnt-this-everywhere>Well then, why isn&rsquo;t this everywhere?
<a class=anchor href=#well-then-why-isnt-this-everywhere>#</a></h1><p>You&rsquo;re probably wondering, if this is so great, why isn&rsquo;t it the default even for gameplay code?</p><p>The reasons are&mldr; a mix of game development pragmatism and engine architecture.</p><ol><li>In gameplay, <code>nullptr</code> is often a valid state</li></ol><p>In low-level engine code, a null pointer often signifies a critical logic error. But in the fluid world of gameplay, <code>nullptr</code> is a crucial and expected piece of information.</p><ul><li>Optional components, an actor that happens to trigger <code>OnBeginOverlap()</code> might have <code>UMyWeaponComponent</code>, but it&rsquo;s not always guaranteed.</li><li>Searching for hit actors, a line trace that hits nothing should return <code>nullptr</code></li><li>Casting should return <code>nullptr</code> if the cast fails due to it being a different type or the pointer itself is invalid.</li></ul><p>In these cases, <code>nullptr</code> isn&rsquo;t a bug. Rather, they&rsquo;re a state that drives a game logic. Using <code>TNonNullPtr</code> here would be incorrect because it would raise an exception on a perfectly valid game state occurances.</p><ol start=2><li><code>check()</code> and <code>ensure()</code> are the pragmatic soltion</li></ol><p>As established before, the primary benefit of <code>TNonNullPtr</code> is the immediate assert. For gameplay programmers, we already have a way that acheive the same goal with more flexibility.</p><ul><li><code>check(Pointer != nullptr);</code>, functionally the same as <code>TNonNullPtr</code>&rsquo;s constructor. It crashes with a clear call stack if the pointer is null, enforcing a hard contract.</li><li><code>ensure(Pointer != nullptr);</code> often preferred in development builds. It logs an error with a call stack but <em>doesn&rsquo;t</em> crash it. Perfect for catching &ldquo;shouldn&rsquo;t-happen-but-might&rdquo; bugs without ruining a playtest session.</li></ul><p>Adding a single line of <code>check()</code> or <code>ensure()</code> line at the top of a function is far more ergonomic and compatible than changing a type signature.</p><h1 class=heading id=the-mind-shift-with-tnonnullptr-spirit>The mind-shift, with <code>TNonNullPtr</code> &lsquo;spirit&rsquo;
<a class=anchor href=#the-mind-shift-with-tnonnullptr-spirit>#</a></h1><p>Let&rsquo;s see how this mindset cleans up a real-world piece of logic</p><p><strong>Before: Defensive and paranoid</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span><span style=color:#6272a4>// This function must constantly worry about its input.
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span><span style=color:#6272a4></span><span style=color:#8be9fd>void</span> UMyWeaponComponent<span style=color:#ff79c6>::</span>ChangeWeapon(UWeapon<span style=color:#ff79c6>*</span> NewWeapon)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span><span>{
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span>	<span style=color:#ff79c6>if</span> (<span style=color:#ff79c6>!</span>NewWeapon)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span><span>	{
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span><span>		UE_LOG(LogTemp, Warning, TEXT(<span style=color:#f1fa8c>&#34;Weapon is null&#34;</span>));
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span><span>		<span style=color:#ff79c6>return</span>; <span style=color:#6272a4>// Early exit, logic flow is split.
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span><span><span style=color:#6272a4></span>	}
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span><span>	<span style=color:#6272a4>// Okay, it&#39;s not null, so we can do stuff.
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span><span><span style=color:#6272a4></span>	NewWeapon<span style=color:#ff79c6>-&gt;</span>SetAmmo(<span style=color:#bd93f9>100</span>);
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12</span><span>}
</span></span></code></pre></div><p><strong>After: Contractual and confident</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span><span style=color:#6272a4>// This function now demands a valid weapon. The _caller_ is responsible for ensuring that the weapon is valid.
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span><span style=color:#6272a4></span><span style=color:#8be9fd>void</span> UMyWeaponComponent<span style=color:#ff79c6>::</span>ChangeWeapon(AWeapon<span style=color:#ff79c6>*</span> NewWeapon)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span><span>{
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span>	<span style=color:#6272a4>// The &#34;bouncer&#34; checks the ID at the door.
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span><span><span style=color:#6272a4></span>	checkf(NewWeapon, TEXT(<span style=color:#f1fa8c>&#34;NewWeapon is null&#34;</span>));
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span><span>	<span style=color:#6272a4>// No more nested ifs! The code is linear, cleaner and easier to read.
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span><span><span style=color:#6272a4></span>	NewWeapon<span style=color:#ff79c6>-&gt;</span>SetAmmo(<span style=color:#bd93f9>100</span>);
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span><span>}
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span><span><span style=color:#6272a4>// The calling code now is forced to be correct.
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12</span><span><span style=color:#6272a4></span><span style=color:#8be9fd>void</span> AMyCharacter<span style=color:#ff79c6>::</span>NotifyActorBeginOverlap(AActor<span style=color:#ff79c6>*</span> OtherActor)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13</span><span>{
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14</span><span>	Super<span style=color:#ff79c6>::</span>NotifyActorBeginOverlap(OtherActor);
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16</span><span>	<span style=color:#ff79c6>if</span> (AWeapon<span style=color:#ff79c6>*</span> Weapon <span style=color:#ff79c6>=</span> Cast<span style=color:#ff79c6>&lt;</span>AWeapon<span style=color:#ff79c6>&gt;</span>(OtherActor))
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17</span><span>	{
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18</span><span>		MyWeaponComponent<span style=color:#ff79c6>-&gt;</span>ChangeWeapon(Weapon);
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19</span><span>	}
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20</span><span>	<span style=color:#ff79c6>else</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21</span><span>	{
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22</span><span>		<span style=color:#6272a4>// We can handle the error here at the source, instead of passing the problem downstream.
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23</span><span><span style=color:#6272a4></span>		UE_LOG(LogTemp, Error, TEXT(<span style=color:#f1fa8c>&#34;AMyCharacter::NotifyActorBeginOverlap called with non-weapon actor %s&#34;</span>), <span style=color:#ff79c6>*</span>OtherActor<span style=color:#ff79c6>-&gt;</span>GetName());
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24</span><span>	}
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25</span><span>}
</span></span></code></pre></div><h1 class=heading id=conclusion>Conclusion
<a class=anchor href=#conclusion>#</a></h1><p>You will likely never use <code>TNonNullPtr</code> in your gameplay code, and that&rsquo;s perfectly OK. Its true value lies in the lesson it teaches; <strong>make your code&rsquo;s intentions clear</strong>.</p><ul><li>It provides both compile-time guard rails and runtime checks</li><li>It shifts the responsibility for nulls to the <em>caller</em>, where it often belongs</li><li>It turns silent, hard-to-trace crashes into loud, easy-to-fix errors</li></ul><p>So next time you write a piece of function, hire a bouncer. Even if it&rsquo;s just a simple <code>check()</code> at the door. Your future self will thank you.</p><h1 class=heading id=acknowledgments>Acknowledgments
<a class=anchor href=#acknowledgments>#</a></h1><p>A special thank you to <a href=https://github.com/apokrif6>apokrif6</a>!</p><p>I was first inspired to dig into this topic after reading their excellent article, <a href=https://apokrif6.github.io/2025/10/22/tnonnullptr-in-unreal-engine.html>TNonNullPtr — Non-Nullable Raw Pointers in Unreal Engine</a>.</p><p>I highly recommend it for a quick, scannable reference guide, especially its fantastic &ldquo;When to use it?&rdquo; table.</p><hr><p>Thanks for reading, hope it helps and useful for you. See you next time!</p></div></article><div class=single-comments><script src=https://giscus.app/client.js data-repo=rezonated/portfolio-workspace data-repo-id=R_kgDOO7BdjA data-category data-category-id=DIC_kwDOO7BdjM4Crcmc data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=dark data-lang=en data-loading=lazy crossorigin=anonymous async></script></div></div></main></div><footer></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script></body><script src=/js/theme-switch.js></script><script defer src=/js/copy-code.js></script><script src=https://code.jquery.com/jquery-3.6.0.min.js></script><script src=/js/lastfm.js></script></html>